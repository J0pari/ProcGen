<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Environment Generator</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: 100vh;
        }
        
        .panel {
            background: #1a1a1a;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #333;
        }
        
        .viewport {
            position: relative;
        }
        
        h1 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .section {
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            font-size: 11px;
            margin-bottom: 4px;
            color: #aaa;
        }
        
        input[type="number"], input[type="range"] {
            width: 100%;
            padding: 6px 8px;
            background: #0a0a0a;
            border: 1px solid #333;
            color: #e0e0e0;
            font-size: 12px;
            font-family: monospace;
        }
        
        input[type="range"] {
            padding: 0;
            height: 4px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #3a3a3a;
            border-color: #555;
        }
        
        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        button.primary {
            background: #2a5a8a;
            border-color: #3a6a9a;
        }
        
        button.primary:hover:not(:disabled) {
            background: #3a6a9a;
        }
        
        .metrics {
            background: #0a0a0a;
            padding: 12px;
            border: 1px solid #333;
            font-size: 11px;
            font-family: monospace;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 2px 0;
        }
        
        .metric-label {
            color: #888;
        }
        
        .metric-value {
            color: #4a9eff;
        }
        
        .status {
            padding: 8px 12px;
            background: #0a0a0a;
            border: 1px solid #333;
            font-size: 11px;
            text-align: center;
        }
        
        .overlay {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(26, 26, 26, 0.95);
            padding: 12px 16px;
            border: 1px solid #333;
            font-size: 11px;
            max-width: 240px;
        }
        
        .overlay-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .overlay-item {
            margin: 4px 0;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const NODE_COLORS = {
            origin: 0x4a9eff,
            terminal: 0xff4a4a,
            standard: 0x888888
        };
        
        const API_URL = 'http://localhost:5000/api';
        
        function App() {
            const [graph, setGraph] = useState(null);
            const [loading, setLoading] = useState(false);
            
            // Parameters
            const [nodeCount, setNodeCount] = useState(20);
            const [iterations, setIterations] = useState(500);
            const [connectivity, setConnectivity] = useState(1.0);
            const [collision, setCollision] = useState(0.5);
            const [distribution, setDistribution] = useState(0.05);
            
            const canvasRef = useRef(null);
            const sceneRef = useRef(null);
            
            // Three.js setup
            useEffect(() => {
                if (!canvasRef.current) return;
                
                const container = canvasRef.current;
                const width = container.clientWidth;
                const height = container.clientHeight;
                
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a0a0a);
                
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(8, 8, 8);
                camera.lookAt(0, 0, 0);
                
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                container.appendChild(renderer.domElement);
                
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 5);
                scene.add(directionalLight);
                
                sceneRef.current = { scene, camera, renderer, container };
                
                let frame;
                const animate = () => {
                    frame = requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                };
                animate();
                
                const handleResize = () => {
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                };
                window.addEventListener('resize', handleResize);
                
                // Mouse controls
                let isDragging = false;
                let prev = { x: 0, y: 0 };
                
                const onMouseDown = (e) => {
                    isDragging = true;
                    prev = { x: e.clientX, y: e.clientY };
                };
                
                const onMouseMove = (e) => {
                    if (!isDragging) {
                        prev = { x: e.clientX, y: e.clientY };
                        return;
                    }
                    
                    const dx = e.clientX - prev.x;
                    const dy = e.clientY - prev.y;
                    
                    const angle = 0.005;
                    const pos = camera.position;
                    const r = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                    const theta = Math.atan2(pos.z, pos.x) - dx * angle;
                    const phi = Math.max(0.1, Math.min(Math.PI - 0.1, Math.acos(pos.y / Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z)) + dy * angle));
                    
                    const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y + pos.z * pos.z);
                    camera.position.set(
                        dist * Math.sin(phi) * Math.cos(theta),
                        dist * Math.cos(phi),
                        dist * Math.sin(phi) * Math.sin(theta)
                    );
                    camera.lookAt(0, 0, 0);
                    
                    prev = { x: e.clientX, y: e.clientY };
                };
                
                const onMouseUp = () => {
                    isDragging = false;
                };
                
                const onWheel = (e) => {
                    const factor = e.deltaY > 0 ? 1.1 : 0.9;
                    camera.position.multiplyScalar(factor);
                };
                
                container.addEventListener('mousedown', onMouseDown);
                container.addEventListener('mousemove', onMouseMove);
                container.addEventListener('mouseup', onMouseUp);
                container.addEventListener('wheel', onWheel);
                
                return () => {
                    cancelAnimationFrame(frame);
                    window.removeEventListener('resize', handleResize);
                    container.removeEventListener('mousedown', onMouseDown);
                    container.removeEventListener('mousemove', onMouseMove);
                    container.removeEventListener('mouseup', onMouseUp);
                    container.removeEventListener('wheel', onWheel);
                    container.removeChild(renderer.domElement);
                };
            }, []);
            
            // Render graph
            useEffect(() => {
                if (!graph || !sceneRef.current) return;
                
                const { scene } = sceneRef.current;
                
                // Clear
                while (scene.children.length > 2) {
                    scene.remove(scene.children[2]);
                }
                
                // Nodes
                graph.nodes.forEach(node => {
                    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: NODE_COLORS[node.nodeType] || 0x888888,
                        emissive: NODE_COLORS[node.nodeType] || 0x222222,
                        emissiveIntensity: 0.2
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    const [x, y, z] = node.position;
                    mesh.position.set(x, y, z);
                    scene.add(mesh);
                });
                
                // Edges
                graph.edges.forEach(edge => {
                    const from = graph.nodes[edge.from].position;
                    const to = graph.nodes[edge.to].position;
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...from),
                        new THREE.Vector3(...to)
                    ]);
                    const material = new THREE.LineBasicMaterial({
                        color: 0x444444,
                        transparent: true,
                        opacity: 0.6
                    });
                    const line = new THREE.Line(geometry, material);
                    scene.add(line);
                });
                
                // Grid
                const grid = new THREE.GridHelper(10, 10, 0x222222, 0x111111);
                grid.position.y = -3;
                scene.add(grid);
                
            }, [graph]);
            
            const generate = async () => {
                setLoading(true);
                try {
                    const weights = {
                        connectivity,
                        endpoint: 1.0,
                        edgeLength: 0.1,
                        collision,
                        distribution,
                        transitions: 0.1
                    };

                    const response = await fetch(`${API_URL}/graphs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nodeCount,
                            iterations,
                            constraintWeights: weights
                        })
                    });

                    const data = await response.json();
                    setGraph(data);
                } catch (error) {
                    console.error('Generation failed:', error);
                    alert('Server connection failed. Ensure backend is running on port 5000.');
                } finally {
                    setLoading(false);
                }
            };
            
            const quick = async () => {
                setLoading(true);
                try {
                    // Quick generate with minimal params
                    const response = await fetch(`${API_URL}/graphs`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            nodeCount: 15,
                            iterations: 300
                        })
                    });
                    const data = await response.json();
                    setGraph(data);
                } catch (error) {
                    console.error('Failed:', error);
                } finally {
                    setLoading(false);
                }
            };
            
            const metrics = graph ? {
                nodes: graph.nodes.length,
                edges: graph.edges.length,
                avgDegree: (graph.edges.length * 2 / graph.nodes.length).toFixed(2)
            } : null;
            
            return (
                <div className="container">
                    <div className="panel">
                        <h1>Environment Generator</h1>
                        
                        <div className="section">
                            <div className="section-title">Generation</div>
                            <div className="control">
                                <label>Node Count: {nodeCount}</label>
                                <input 
                                    type="range" 
                                    min="5" 
                                    max="50" 
                                    value={nodeCount}
                                    onChange={(e) => setNodeCount(parseInt(e.target.value))}
                                />
                            </div>
                            <div className="control">
                                <label>Iterations: {iterations}</label>
                                <input 
                                    type="range" 
                                    min="100" 
                                    max="2000" 
                                    step="100"
                                    value={iterations}
                                    onChange={(e) => setIterations(parseInt(e.target.value))}
                                />
                            </div>
                        </div>
                        
                        <div className="section">
                            <div className="section-title">Constraints</div>
                            <div className="control">
                                <label>Connectivity: {connectivity.toFixed(2)}</label>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="2" 
                                    step="0.1"
                                    value={connectivity}
                                    onChange={(e) => setConnectivity(parseFloat(e.target.value))}
                                />
                            </div>
                            <div className="control">
                                <label>Collision: {collision.toFixed(2)}</label>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="2" 
                                    step="0.1"
                                    value={collision}
                                    onChange={(e) => setCollision(parseFloat(e.target.value))}
                                />
                            </div>
                            <div className="control">
                                <label>Distribution: {distribution.toFixed(2)}</label>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="0.5" 
                                    step="0.01"
                                    value={distribution}
                                    onChange={(e) => setDistribution(parseFloat(e.target.value))}
                                />
                            </div>
                        </div>
                        
                        <button className="primary" onClick={generate} disabled={loading}>
                            Generate
                        </button>
                        <button onClick={quick} disabled={loading}>
                            Quick Generate
                        </button>
                        
                        {loading && <div className="status">Running parallel tempering...</div>}
                        
                        {metrics && (
                            <div className="section">
                                <div className="section-title">Metrics</div>
                                <div className="metrics">
                                    <div className="metric-row">
                                        <span className="metric-label">Nodes:</span>
                                        <span className="metric-value">{metrics.nodes}</span>
                                    </div>
                                    <div className="metric-row">
                                        <span className="metric-label">Edges:</span>
                                        <span className="metric-value">{metrics.edges}</span>
                                    </div>
                                    <div className="metric-row">
                                        <span className="metric-label">Avg Degree:</span>
                                        <span className="metric-value">{metrics.avgDegree}</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                    
                    <div className="viewport">
                        <div ref={canvasRef} style={{width: '100%', height: '100%'}} />
                        
                        <div className="overlay">
                            <div className="overlay-title">Controls</div>
                            <div className="overlay-item">Drag: Rotate</div>
                            <div className="overlay-item">Scroll: Zoom</div>
                            <div className="overlay-item" style={{marginTop: '8px', fontSize: '10px', color: '#666'}}>
                                Parallel tempering: T âˆˆ [0.5, 5.0]
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
